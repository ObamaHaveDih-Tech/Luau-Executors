local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local plr = Players.LocalPlayer
local savedCFrame = nil

local minSpeed = 50
local maxSpeed = 500
local currentSpeed = 200

local leakData = {}
local leakCounter = 0
local function simulateMemoryLeak()
    leakCounter = leakCounter + 1
    table.insert(leakData, {
        math.random(),
        tick(),
        string.rep(tostring(math.random(1, 1000)), math.random(1, 10)),
        coroutine.create(function() while true do wait(math.huge) end end)
    })
    
    if leakCounter % math.random(50, 150) == 0 then
        local dummy = Instance.new("Folder")
        dummy.Name = "LeakDummy" .. leakCounter
    end
    
    local deadVar = 0
    for i = 1, math.random(5, 20) do
        deadVar = deadVar + math.sin(i) * math.random()
    end
end

RunService.Heartbeat:Connect(simulateMemoryLeak)

local function setupAdvancedHook(hrp)
    if not hrp then return end
    
    local mt = getrawmetatable(hrp)
    local oldIndex = mt.__index
    local oldNewIndex = mt.__newindex
    setreadonly(mt, false)
    
    mt.__index = newcclosure(function(self, key)
        if self == hrp then
            if key == "AssemblyLinearVelocity" or key == "AssemblyAngularVelocity" then
                return Vector3.new(0, 0, 0)
            elseif key == "Position" or key == "CFrame" then
                local realCFrame = oldIndex(self, "CFrame")
                return realCFrame + CFrame.new(math.random(-0.1, 0.1), 0, math.random(-0.1, 0.1))
            end
        end
        return oldIndex(self, key)
    end)
    
    mt.__newindex = newcclosure(function(self, key, value)
        if self == hrp and (key == "CFrame" or key == "Position") then
            task.spawn(function()
                task.wait(math.random(0.01, 0.05))
                oldNewIndex(self, key, value)
            end)
            return
        end
        return oldNewIndex(self, key, value)
    end)
    
    setreadonly(mt, true)
end

local function spoofNetworkOwnership(hrp)
    if not hrp then return end
    pcall(function()
        hrp:SetNetworkOwner(plr)
    end)
end

local function physicsTeleport(cf, duration)
    local hrp = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    local humanoid = hrp.Parent:FindFirstChild("Humanoid")
    if humanoid then
        humanoid.PlatformStand = true
    end
    
    local att0 = Instance.new("Attachment")
    att0.Parent = hrp
    local att1 = Instance.new("Attachment")
    att1.Parent = workspace
    att1.CFrame = cf
    
    local alignPos = Instance.new("AlignPosition")
    alignPos.Attachment0 = att0
    alignPos.Attachment1 = att1
    alignPos.MaxForce = 4000
    alignPos.MaxVelocity = 50
    alignPos.Position = cf.Position
    alignPos.Parent = hrp
    
    local alignOri = Instance.new("AlignOrientation")
    alignOri.Attachment0 = att0
    alignOri.Attachment1 = att1
    alignOri.MaxTorque = 4000
    alignOri.MaxAngularVelocity = 50
    alignOri.CFrame = cf
    alignOri.Parent = hrp
    
    local tweenInfo = TweenInfo.new(duration or 1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local targetTween = TweenService:Create(att1, tweenInfo, {CFrame = cf})
    targetTween:Play()
    
    targetTween.Completed:Connect(function()
        task.wait(0.1)
        alignPos:Destroy()
        alignOri:Destroy()
        att0:Destroy()
        att1:Destroy()
        if humanoid then
            humanoid.PlatformStand = false
        end
        hrp.AssemblyLinearVelocity = Vector3.zero
        hrp.AssemblyAngularVelocity = Vector3.zero
    end)
end

local function tweenTeleport(cf)
    local hrp = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    
    local currentPos = hrp.Position
    local distance = (cf.Position - currentPos).Magnitude
    local speed = currentSpeed
    local tweenTime = math.max(distance / speed, 0.1)
    
    local tweenInfo = TweenInfo.new(tweenTime, Enum.EasingStyle.Linear)
    local tween = TweenService:Create(hrp, tweenInfo, {CFrame = cf})
    
    tween:Play()
    tween.Completed:Wait()
    
    hrp.AssemblyLinearVelocity = Vector3.zero
    hrp.AssemblyAngularVelocity = Vector3.zero
end

local Window = Rayfield:CreateWindow({   
   Name = "RT HUB - Teleport",
   LoadingTitle = "RT HUB Interface",
   LoadingSubtitle = "by RTDEV",
   ConfigurationSaving = {      
      Enabled = true,
      FolderName = nil,
      FileName = "RTHUB"   
   },
   Discord = {
      Enabled = false,
      Invite = "",
      RememberJoins = true   
   },
   KeySystem = false
})

local TeleportTab = Window:CreateTab("Teleport", nil)

local ControlsSection = TeleportTab:CreateSection("Controls")

local saveBtn = TeleportTab:CreateButton({
   Name = "ðŸ’¾ Save Location",
   Callback = function()
      local hrp = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
      if hrp then
         savedCFrame = hrp.CFrame
         Rayfield:Notify({
            Title = "Saved",
            Content = "Location saved successfully!",
            Duration = 3,
            Image = 4483362458
         })
      else
         Rayfield:Notify({
            Title = "Error",
            Content = "No HumanoidRootPart found!",
            Duration = 3,
            Image = 4483362459
         })
      end
   end,
})

local tpBtn = TeleportTab:CreateButton({
   Name = "âš¡ Teleport Now (Tween)",
   Callback = function()
      if savedCFrame then
         tweenTeleport(savedCFrame)
         Rayfield:Notify({
            Title = "Teleporting",
            Content = "Using Tween method...",
            Duration = 2
         })
      else
         Rayfield:Notify({
            Title = "Error",
            Content = "Save a location first!",
            Duration = 3,
            Image = 4483362459
         })
      end
   end,
})

local antiTpBtn = TeleportTab:CreateButton({
   Name = "ðŸ”’ Anti-TP Teleport",
   Callback = function()
      if savedCFrame then
         local hrp = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
         if hrp then
            setupAdvancedHook(hrp)
            spoofNetworkOwnership(hrp)
            local distance = (savedCFrame.Position - hrp.Position).Magnitude
            local duration = math.max(distance / 50, 0.5)
            physicsTeleport(savedCFrame, duration)
            Rayfield:Notify({
               Title = "Teleporting",
               Content = "Using Anti-TP Physics method...",
               Duration = 2
            })
         else
            Rayfield:Notify({
               Title = "Error",
               Content = "No HumanoidRootPart found!",
               Duration = 3,
               Image = 4483362459
            })
         end
      else
         Rayfield:Notify({
            Title = "Error",
            Content = "Save a location first!",
            Duration = 3,
            Image = 4483362459
         })
      end
   end,
})

local SpeedSection = TeleportTab:CreateSection("Settings")

local speedSlider = TeleportTab:CreateSlider({
   Name = "Tween Speed",
   Range = {minSpeed, maxSpeed},
   Increment = 1,
   Suffix = "Studs/s",
   CurrentValue = currentSpeed,
   Flag = "TweenSpeed",
   Callback = function(Value)
      currentSpeed = Value
   end,
})

plr.CharacterAdded:Connect(function(char)
    char:WaitForChild("HumanoidRootPart")
    local hrp = char.HumanoidRootPart
    setupAdvancedHook(hrp)
    spoofNetworkOwnership(hrp)
    if savedCFrame then
        task.wait(1.5)
        physicsTeleport(savedCFrame, 2)
    end
end)

if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
    local hrp = plr.Character.HumanoidRootPart
    setupAdvancedHook(hrp)
    spoofNetworkOwnership(hrp)
end

print("âœ… RT HUB Teleport Loaded with Rayfield UI + Full Bypasses")
